% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dtedit.R
\name{dtedit}
\alias{dtedit}
\title{Create a DataTable with Add, Edit and Delete buttons.}
\usage{
dtedit(
  input,
  output,
  session,
  thedataframe,
  view.cols = names(isolate(if (is.reactive(thedataframe)) {     thedataframe() } else
    {     thedataframe })),
  edit.cols = names(isolate(if (is.reactive(thedataframe)) {     thedataframe() } else
    {     thedataframe })),
  edit.label.cols = edit.cols,
  input.types,
  input.choices = NULL,
  input.choices.reactive = NULL,
  selectize = TRUE,
  modal.size = "m",
  text.width = "100\%",
  textarea.width = "570px",
  textarea.height = "200px",
  date.width = "100px",
  numeric.width = "100px",
  select.width = "100\%",
  defaultPageLength = 10,
  title.delete = "Delete",
  title.edit = "Edit",
  title.add = "New",
  title.download = "Download",
  title.upload = "Upload",
  label.delete = "",
  label.edit = "",
  label.add = "",
  label.copy = "",
  label.download = "",
  label.upload = "",
  icon.delete = icon("trash"),
  icon.edit = icon("edit"),
  icon.add = icon("plus"),
  icon.copy = icon("copy"),
  icon.upload = icon("upload"),
  show.delete = TRUE,
  show.update = TRUE,
  show.insert = TRUE,
  show.copy = TRUE,
  show.download = FALSE,
  show.upload = FALSE,
  callback.delete = function(data, row) { },
  callback.update = function(data, olddata, row) { },
  callback.insert = function(data, row) { },
  click.time.threshold = 2,
  datatable.options = list(pageLength = defaultPageLength),
  datatable.name = "editdt"
)
}
\arguments{
\item{input}{Shiny input object passed from the server.}

\item{output}{Shiny output object passed from the server.}

\item{session}{Shiny session object passed from the server}

\item{thedataframe}{a data frame to view and edit. can be a reactive}

\item{view.cols}{character vector with the column names to show in the DataTable.
This can be a subset of the full \code{data.frame}.}

\item{edit.cols}{character vector with the column names the user can edit/add.
This can be a subset of the full \code{data.frame}.}

\item{edit.label.cols}{character vector with the labels to use on the edit
and add dialogs. The length and order of \code{code.cols.labels} must
correspond to \code{edit.cols}.}

\item{input.types}{a character vector where the name corresponds to a column
in \code{edit.cols} and the value is the input type. Possible values
are \code{dateInput}, \code{selectInput}, \code{selectInputMultiple},
\code{selectInputReactive}, \code{selectInputMultipleReactive}, \code{numericInput}, \code{textInput}, \code{textAreaInput},
or \code{passwordInput}.
The most common case where this parameter is desirable is when a text
area is required instead of a simple text input.}

\item{input.choices}{a list of character vectors. The names of each element in the list must
correspond to a column name in the data. The value, a character vector, are the options
presented to the user for data entry, in the case of input type \code{selectInput}).
In the case of input type \code{selectInputReactive} or \code{selectInputMultipleReactive}, the value
is the name of the reactive. in 'input.choices.reactive'}

\item{input.choices.reactive}{a named list of reactives, referenced in 'input.choices'
to use for input type \code{selectInputReactive} or \code{selectInputMultipleReactive}.
The reactive itself is a character vector.}

\item{selectize}{Whether to use selectize.js or not. See \code{\link{selectInput}} for more info.}

\item{modal.size}{the size of the modal dialog. See \code{\link{modalDialog}}.}

\item{text.width}{width of text inputs.}

\item{textarea.width}{the width of text area inputs.}

\item{textarea.height}{the height of text area inputs.}

\item{date.width}{the width of data inputs}

\item{numeric.width}{the width of numeric inputs.}

\item{select.width}{the width of drop down inputs.}

\item{defaultPageLength}{number of rows to show in the data table by default.}

\item{title.delete}{the title of the dialog box for deleting a row.}

\item{title.edit}{the title of the dialog box for editing a row.}

\item{title.add}{the title of the dialog box for inserting a new row.}

\item{label.delete}{the label of the delete button.}

\item{label.edit}{the label of the edit button.}

\item{label.add}{the label of the add button.}

\item{label.copy}{the label of the copy button.}

\item{show.delete}{whether to show/enable the delete button.}

\item{show.update}{whether to show/enable the update button.}

\item{show.insert}{whether to show/enable the insert button.}

\item{show.copy}{whether to show/enablre the copy button.}

\item{callback.delete}{a function called when the user deletes a row. This function should
return an updated data.frame.}

\item{callback.update}{a function called when the user updates a row. This function should
return an updated data.frame.}

\item{callback.insert}{a function called when the user inserts a new row. This function should
return an updated data.frame.}

\item{click.time.threshold}{This is to prevent duplicate entries usually by double clicking the
save or update buttons. If the user clicks the save button again within this amount of
time (in seconds), the subsequent click will be ignored. Set to zero to disable this
feature. For developers, a message is printed using the warning function.}

\item{datatable.options}{options passed to \code{\link{DT::renderDataTable}}.
See \url{https://rstudio.github.io/DT/options.html} for more information.}
}
\value{
Returns a list of reactive values. \code{return_values$data()} contains
 the current state of DTedit's copy of the data. \code{return_values$edit.count()}
 contains the number of edits done within DTedit (does not include changes to DTedit's
 copy of the data secondary to changes in \code{thedataframe}, if \code{thedataframe} is a reactive)
}
\description{
dtedit - server function
}
\details{
Use in conjunction with \code{callModule} and \code{dteditUI} to create
editable datatables. \code{dtedit} is used in the 'server' component of the
shiny app.

This object will maintain data state. However, in order of the data to persist
between Shiny instances, data needs to be saved to some external format (e.g.
database or R data file). The callback functions provide a mechanism for this
function to interact with a permanent data storage scheme. The callback
functions are called when the user adds, updates, or deletes a row from the
data table. The callback must accept two parameters: \code{data} and \code{row}.
For inserting and updating, the \code{data} object is the current state of
data table including any additions or updates. The \code{row} parameter indicates
which row from \code{data} was modified (or added). For deletions, however,
the \code{data} represents the data table just before deleting the specified
row. That is, if \code{callback.delete} returns a \code{data.frame}, that will
be the new data table; otherwise this function will remove row \code{row} from
\code{data} and that will become the current data table.

The callback functions may throw errors (see e.g. \code{stop}) if there are
problems with data. That is, if data validation checks indicate data problems
before inserting or updating a row the function may throw an error. Note that
the error message will be presented to the user so providing messages
meaningful to the user is recommended. Moreover, if an error is thrown, the
modal dialog is not dismissed and the user can further edit the data and
retry the insertion or update.

Callback functions may return a \code{data.frame}. When a \code{data.frame} is
returned that will become the current state of the data table. If anything
else is returned then the internal \code{data.frame} will be used.
}
\examples{
# minimal DTedit example
\donttest{
library(shiny)
library(DTedit)

server <- function(input, output) {
  
  Grocery_List <- callModule(dtedit, 'Grocery_List',
                             thedataframe = data.frame(Buy = c('Tea', 'Biscuits', 'Apples'),
                                                       Quantity = c(7, 2, 5),
                                                       stringsAsFactors = FALSE)
                             )
}

ui <- fluidPage(
  h3('Grocery List'),
  dteditUI('Grocery_List')
)

shinyApp(ui = ui, server = server)
}
}
\seealso{
\code{\link{dteditUI}} : the companion user-interface function.\cr

 \itemize{
 \item \code{example("dtedit")} for a simple example.
 \item \code{example("dteditUI")} for a simple example with reactive dataframe
 \item \code{dtedit_demo()} for a more complex example. Includes database interaction
 and interactions between the data of multiple datatables.
 }

Other Datatable Edit functions: 
\code{\link{dteditUI}()}
}
\concept{Datatable Edit functions}
